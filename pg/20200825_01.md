# 多版本并发控制
从宽泛的意义上来讲，有三种并发控制技术，分别是多版本并发控制MVCC、严格两阶段锁定S2PL、乐观并发控制OCC，每种技术都有多种变体。PostgreSQL使用一种MVCC的变体，叫做快照隔离SI。但SI无法实现真正的可串行化，为了解决这个问题，PostgreSQL从9.1版本之后添加了可串行化快照隔离SSI。

**PostgreSQL中的事务隔离等级：**

SQL标准允许更严格的行为：四种隔离级别只定义了哪种现象不能发生，但是没有定义哪种现象必须发生。

| 隔离级别	| 脏读	| 不可重复读	| 幻读	| 序列化异常 |
| :- | :- | :- | :- | :- |
| 读未提交	| 可能，但不在PG中	| 可能	| 可能	| 可能 | 
| 读已提交	| 不可能	| 可能	| 可能	| 可能 | 
| 可重复读	| 不可能	| 不可能	| 可能，但不在PG中	| 可能 | 
| 可序列化	| 不可能	| 不可能	| 不可能	| 不可能 | 

PostgreSQL对DML使用SSI，对DDL使用2PL。

## 1. 事务标识
当事务开始时，事务管理器会为其分配一个称为事务标识的唯一标识符txid（transaction id），txid是一个32位无符号整数，取值空间大小约为42亿。
```sql
postgres=# begin;
BEGIN
postgres=# select txid_current();
 txid_current
--------------
          587
(1 row)
```

PostgreSQL保留以下三个特殊txid：
- 0，表示无效的txid。
- 1，表示初始启动的txid，仅用于数据库集群的初始化过程。
- 2，表示冻结的txid。

注意，txid并非是在`BEGIN`命令执行时分配的。在PostgreSQL中，当执行`BEGIN`命令后的第一条命令时，事务管理器才会分配txid，并真正启动其事务。

## 2. 元组结构
表页中的堆元组分为普通数据元组和TOAST元组，下面介绍普通元组。

堆元组由三个部分组成，即HeapTupleHeaderData结构、空值位图、用户数据：
![image](https://github.com/bertramcheng/blog/blob/master/pg/20200825_01_pic_001.jpg)

- t_xmin，保存插入此元组的事务的txid。
- t_xmax，保存删除或更新此元组的事务的txid。如果尚未删除或更新此元组，则t_xmax设置为0，即无效。
- t_cid，保存命令标识（command id），cid的意思是在当前事务中，执行当前命令之前执行了多少SQL命令，从0开始计数。例如，假设我们在单个事务中执行了3条`INSERT`命令：`BEGIN`、`INSERT`、`INSERT`、`INSERT`，如果第一条命令插入此元组，则该元组的t_cid会被设置为0，如果第二条命令插入此元组，则其t_cid会被设置为1。
- t_ctid，保存着指向自身或新元组的元组标识符tid。在更新该元组时，t_ctid会指向新版本的元组，否则t_ctid会指向自己。

## 3. 元组的增、删、改
```sql
postgres=# create extension pageinspect;
CREATE EXTENSION
```

### 3.1 插入
在插入操作中，新元组将直接插入目标表的页面中：
![image](https://github.com/bertramcheng/blog/blob/master/pg/20200825_01_pic_002.jpg)

```sql
postgres=# create table t_test (data text);
CREATE TABLE
postgres=# begin;
BEGIN
postgres=# select txid_current();
 txid_current
--------------
          99
(1 row)

postgres=# insert into t_test (data) values ('A');
INSERT 0 1
postgres=# select lp as tuple, t_xmin, t_xmax, t_field3 as t_cid, t_ctid
    from heap_page_items(get_raw_page('t_test', 0));
 tuple | t_xmin | t_xmax | t_cid | t_ctid
-------+--------+--------+-------+--------
     1 |     99 |      0 |     0 | (0,1)
(1 row)
```

### 3.2 删除
在删除操作中，目标元组只是在逻辑上被标记为删除。目标元组的t_xmax字段将被设置为执行`DELETE`命令事务的txid：
![image](https://github.com/bertramcheng/blog/blob/master/pg/20200825_01_pic_003.jpg)

```sql
postgres=# begin;
BEGIN
postgres=# delete from t_test ;
DELETE 1
postgres=# select lp as tuple, t_xmin, t_xmax, t_field3 as t_cid, t_ctid
    from heap_page_items(get_raw_page('t_test', 0));
 tuple | t_xmin | t_xmax | t_cid | t_ctid
-------+--------+--------+-------+--------
     1 |    100 |    111 |     0 | (0,1)
(1 row)
```

### 3.3 更新
在更新操作中，PostgreSQL在逻辑上实际执行的是删除最新的元组，并插入一条新的元组：
![image](https://github.com/bertramcheng/blog/blob/master/pg/20200825_01_pic_004.jpg)

```sql
postgres=# insert into t_test (data) values ('A');
INSERT 0 1
postgres=# select lp as tuple, t_xmin, t_xmax, t_field3 as t_cid, t_ctid
    from heap_page_items(get_raw_page('t_test', 0));
 tuple | t_xmin | t_xmax | t_cid | t_ctid
-------+--------+--------+-------+--------
     1 |     99 |      0 |     0 | (0,1)
(1 row)

postgres=# begin;
BEGIN
postgres=# update t_test set data = 'B';
UPDATE 1
postgres=# select lp as tuple, t_xmin, t_xmax, t_field3 as t_cid, t_ctid
    from heap_page_items(get_raw_page('t_test', 0));
 tuple | t_xmin | t_xmax | t_cid | t_ctid
-------+--------+--------+-------+--------
     1 |     99 |    100 |     0 | (0,2)
     2 |    100 |      0 |     0 | (0,2)
(2 rows)

postgres=# update t_test set data = 'C';
UPDATE 1
postgres=# select lp as tuple, t_xmin, t_xmax, t_field3 as t_cid, t_ctid
    from heap_page_items(get_raw_page('t_test', 0));
 tuple | t_xmin | t_xmax | t_cid | t_ctid
-------+--------+--------+-------+--------
     1 |     99 |    100 |     0 | (0,2)
     2 |    100 |    100 |     0 | (0,3)
     3 |    100 |      0 |     1 | (0,3)
(3 rows)
```

如果txid=100的事务已经提交，那么Tuple_1和Tuple_2就成了死元组，而如果txid=100的事务中止，Tuple_2和Tuple_3就成了死元组。

### 3.4 空闲空间映射
插入堆或者索引元组时，PostgreSQL使用表与索引相对应的FSM来选择可供插入的页面。

所有FSM都以后缀fsm存储，在需要时它们会被加载到共享内存中。

**pg_freespacemap**：
```sql
postgres=# create table t_test2 (data int);
CREATE TABLE
postgres=# create extension pg_freespacemap ;
CREATE EXTENSION
postgres=# insert into t_test2 (data) select generate_series(1, 1000);
INSERT 0 1000
postgres=# select *, round(avail*100/8192, 2) from pg_freespace('t_test2');
 blkno | avail | round
-------+-------+-------
     0 |     0 |  0.00
     1 |     0 |  0.00
     2 |     0 |  0.00
     3 |     0 |  0.00
     4 |     0 |  0.00
(5 rows)

postgres=# vacuum t_test2;
VACUUM
postgres=# select *, round(avail*100/8192, 2) as "freespace ratio" from pg_freespace('t_test2');
 blkno | avail | freespace ratio
-------+-------+-----------------
     0 |     0 |            0.00
     1 |     0 |            0.00
     2 |     0 |            0.00
     3 |     0 |            0.00
     4 |  4704 |           57.00
(5 rows)
```

## 4. 提交日志
PostgreSQL在提交日志（commit log，CLOG）中保存事务的状态，CLOG分配于共享内存中，并用于事务处理过程的全过程。

PostgreSQL定义了4种事务状态，即IN_PROGRESS、COMMITTED、ABORTED、SUB_COMMITTED。

CLOG在逻辑上是一个数组，由共享内存中一系列8KB页面组成。数组的序号索引对应着相应事务的标识，其内容是相应事务的状态：
![image](https://github.com/bertramcheng/blog/blob/master/pg/20200825_01_pic_005.jpg)

- T1：txid 200提交，txid 200的状态从IN_PROGRESS变为COMMMITTED。
- T2：txid 201提交，txid 201的状态从IN_PROGRESS变为ABORTED。

txid不断前进，当CLOG空间耗尽时，就会追加分配一个新的页面。

当PostgreSQL关机或执行存档过程时，CLOG数据会写入pg_clog子目录下的文件中（在10.0版本，pg_clog被重命名为pg_xact）。这些文件被命名为0000、0001等，文件的最大尺寸为256KB。例如当CLOG使用8个页面时，从第1页到第8页的总大小为64KB，这些数据会写入文件0000（64KB）中，当CLOG使用37个页面时（296KB），数据会写入0000和0001两个文件中，其大小分别为256KB和40KB。

当PostgreSQL启动时会加载存储在pg_clog中的文件，用其数据初始化CLOG。

CLOG的大小会不断增长，因为只有CLOG一填满就会追加新的页面。但并非所有数据都是必要的。清理过程会定期删除不需要的就数据（CLOG页面和文件）。

## 5. 事务快照
事务快照是一个数据集，存储着某个特定事务在某个特定时间点所看到的事务状态信息：哪些事务处于活跃状态。活跃状态意味着事务正在进行中或还没有开始。

**内置函数txid_current_snapshot及其文本表示：**
```sql
postgres=# select txid_current_snapshot();
 txid_current_snapshot
-----------------------
 100:104:100,102
(1 row)
```

txid_current_snapshot的文本表示是`xmin:xmax:xip_list`，各部分描述如下：

- xmin，最早仍然活跃的事务的txid。所有比它早的事务，要么已经提交并可见，要么已经回滚并生成死元组。

- xmax，第一个尚未分配的txid。所有txid >= xmax的事务在获取快照时尚未启动，因此其结果对当前事务不可见。

- xip_list，获取快照时活跃事务的txid列表。该列表仅包括xmin与xmax之间的txid。

以下是两个具体的示例：
![image](https://github.com/bertramcheng/blog/blob/master/pg/20200825_01_pic_006.jpg)

第一个例子是`100:100:`，表示：
- xmin为100，txid < 100的事务部活跃。
- xmax为100，txid >= 100的事务是活跃的。

第二个例子是`100:104:100,102`，表示：
- txid < 100的事务部活跃。
- txid >= 104的事务是活跃的。
- txid = 100和102的事务是活跃的，而txid = 101和103的事务不活跃。

事务快照有事务管理器提供。在`READ COMMITTED`隔离级别，事务在执行每条SQL时都会获取快照，在`REPEATABLE READ`和`SERIALIZABLE`隔离级别，事务只会在执行第一条SQL时获取一次快照。获取的事务快照用于元组的可见性检查。

使用获取的快照进行可见性检查时，所有活跃的事务都必须被当成IN_PROGRESS的事务等同对待，无论它们实际上是否已经提交或中止。这条规则正是`READ COMMITTED`和`REPEATABLE READ`/`SERIALIZABLE`隔离级别中表现差异的根本来源。

下面通过一个具体的场景来描述事务与事务管理器：
![image](https://github.com/bertramcheng/blog/blob/master/pg/20200825_01_pic_007.jpg)

事务管理器始终保持着当前运行的事务的有关信息。

- T1：A启动并执行第一条SQL命令。执行第一条命令时，A请求此刻的txid和快照。在这种情况下，事务管理器分配txid = 200，并返回事务快照`200:200:`。

- T2：B启动并执行第一条SQL命令。事务管理器分配txid = 201，并返回事务快照`200:200:`，因为A正在进行中，所以无法从B中看到A。

- T3：C启动并执行第一条SQL命令。事务管理器分配txid = 202，并返回事务快照`200:200:`，因此不能从C中看到A和B。

- T4：A已提交。事务管理器删除有关此事务的信息。

- T5：B和C各自执行SQL命令。

B需要一个新的事务快照，因为它使用了`READ COMMITTED`隔离等级。在这种情况下，B获取新快照`201:201:`，A的变更对B可见。

C不需要新的事务快照，因为它处于`REPEATABLE READ`隔离等级，它继续使用已获取的快照，即`200:200:`，A的变更仍然对C不可见。
