# 深度理解依赖注入（Dependence Injection）

## 1. 依赖在哪里
例如，开发一个电影列举器（MovieList），这个电影列举器需要使用一个电影查找器（MovieFinder）提供的服务，伪码如下：

```java
// 服务的接口
public interface MovieFinder {
    ArrayList findAll();
}

// 服务的消费者
class MovieLister {
    // 消费者内部包含一个将指向具体服务类型的实体对象
    private MovieFinder finder;
    
    // 消费者需要在某一个时刻去实例化具体的服务。
    // 这是我们要解耦的关键所在，因为这样的处理方式
    // 造成了服务消费者和服务提供者的强耦合关系（这种耦合是在编译期就确定下来的）。
    public MovieLister() {
        finder = new ColonDelimitedMovieFinder("movies1.txt");
    }
    
    public Movie[] moviesDirectedBy(String arg) {
        List allMovies = finder.findAll();
        
        for (Iterator it = allMovies.iterator(); it.hasNext();) {
            Movie movie = (Movie) it.next();
            if (!movie.getDirector().equals(arg)) it.remove();
        }
        return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);
    }
}
```

从上面代码的注释中可以看到，MovieLister和ColonDelimitedMovieFinder（这可以是任意一个实现了MovieFinder接口的类型）之间存在强耦合关系，如下图所示：

![image](https://github.com/bertramcheng/blog/blob/master/code/20201013_01_pic_001.jpg)

这使得MovieList很难作为一个成熟的组件去发布，因为在不同的应用环境中，它所要依赖的电影查找器可能是千差万别的。所以，为了能实现真正的基于组件的开发，必须有一种机制能同时满足下面两个要求：

- 解除MovieList对具体MoveFinder类型的强依赖（编译期依赖）。
- 在运行的时候为MovieList提供正确的MovieFinder类型的实例。
 
换句话说，就是在运行的时候才产生MovieList和MovieFinder之间的依赖关系（把这种依赖关系在一个合适的时候“注入”），这恐怕就是Dependency Injection这个术语的由来。

依赖关系在OO程序中是广泛存在的，只要A类型中用到了B类型实例，A就依赖于B。我们提到过解除强依赖，这并不是说MovieList和MovieFinder之间的依赖关系不存在了，事实上MovieList无论如何也需要某类MovieFinder提供的服务，我们只是把这种依赖的建立时间推后了，从编译器推迟到运行时了。

可以把MovieList看成我们要构建的主系统，而MovieFinder是系统中的plugin，主系统并不强依赖于任何一个插件，但一旦插件被加载，主系统就应该可以准确调用适当插件的功能。

其实不管是面向服务的编程模式，还是基于插件的框架式编程，为了实现松耦合（服务调用者和提供者之间的或者框架和插件之间的），都需要在必要的位置实现面向接口编程，在此基础之上，还应该有一种方便的机制实现具体类型之间的运行时绑定，这就是DI所要解决的问题。

# 2.DI的实现方式
如果我们的系统实现了依赖注入，组件间的依赖关系就变成了下图：

![image](https://github.com/bertramcheng/blog/blob/master/code/20201013_01_pic_001.jpg)

说白了，就是要提供一个容器，由容器来完成：（1）具体ServiceProvider的创建，（2）ServiceUser和ServiceProvider的运行时绑定。

下面我们就依次来看一下三种典型的依赖注入方式的实现。特别要说明的是，要理解依赖注入的机制，关键是理解容器的实现方式。
